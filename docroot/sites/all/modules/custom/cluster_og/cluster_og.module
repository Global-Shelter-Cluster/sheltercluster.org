<?php
/**
 * @file
 * Handles all OG related funcitonalities.
 */

include_once 'cluster_og.features.inc';

/**
 * Implements hook_menu().
 */
function cluster_og_menu() {
  module_load_include('inc', 'cluster_og', 'includes/cluster_og.menu');
  $items = array();
  // Generate the geographic_region menu.
  $items = array_merge(cluster_og_menu_region(), $items);
  return $items;
}

/**
 * Page callback.
 * Display a Region Group page.
 * @param $nid
 *  The geographic_region node id.
 * @param $path
 *  The associated menu item path.
 */
function cluster_og_geographic_region($nid, $path) {
  $content['region_group'] = node_view(node_load($nid), 'full');
  return $content;
}

/**
 * Node API.
 */

/**
 * Implements hook_node_view().
 */
function cluster_og_node_view($node, $view_mode) {
  $bundle = $node->type;

  if ($view_mode !== 'full') {
    // Only add these blocks to the full page view of the nodes.
    return;
  }

  // Group specific actions.
  if (og_is_group_type('node', $bundle)) {
    $gid = $node->nid;

    // Make a list of contact member users.
    if ($contact_member_rid = _cluster_og_get_role_id_by_name($bundle, 'contact member')) {
      if ($contact_members_ids = _cluster_og_get_group_users_by_role($gid, $contact_member_rid)) {
        $accounts = user_load_multiple($contact_members_ids);
        // Prepare a render array.
        $member = array(
          '#theme_wrappers' => array('cluster_og_contact_member'),
          '#total' => count($accounts),
        );

        // Add account render arrays.
        foreach ($accounts as $account) {
          $member[$account->uid] = array(user_view($account, 'contact_member'));
        }
        $node->content['contact_members'] = $member;
      }
    }

    if ($bundle === 'geographic_region') {
      $region_and_descendants_ids = _cluster_og_get_region_descendants($node->nid, TRUE);

      // Make a list of responses associated to this region and to its descendants.
      if ($descendant_response_ids = _cluster_og_get_region_responses($region_and_descendants_ids)) {
        $response_nodes = node_load_multiple($descendant_response_ids);
        // Prepare a render array.
        $responses = array(
          '#theme_wrappers' => array('cluster_og_related_responses'),
          '#total' => count($response_nodes),
        );

        // Add node render arrays.
        foreach ($response_nodes as $response_node) {
          $responses[$response_node->nid] = node_view($response_node, 'teaser'); //TODO: change teaser to custom view mode
        }
        $node->content['related_responses'] = $responses;
      }

      // Make a list of hubs associated to this region and to its descendants.
      if ($related_hub_ids = _cluster_og_get_region_hubs($region_and_descendants_ids)) {
        $hub_nodes = node_load_multiple($related_hub_ids);
        // Prepare a render array.
        $hubs = array(
          '#theme_wrappers' => array('cluster_og_related_hubs'),
          '#total' => count($hub_nodes),
        );

        // Add node render arrays.
        foreach ($hub_nodes as $hub_node) {
          $hubs[$hub_node->nid] = node_view($hub_node, 'teaser'); //TODO: change teaser to custom view mode
        }
        $node->content['related_hubs'] = $hubs;
      }
    }

    if ($bundle === 'response') {
      $descendant_response_ids = _cluster_og_get_response_descendants($node->nid);
      $response_and_descendant_ids = array_merge(array($node->nid), $descendant_response_ids);

      // Make a list of hubs associated to this response and to its descendants.
      if ($related_hub_ids = _cluster_og_get_response_hubs($response_and_descendant_ids)) {
        $hub_nodes = node_load_multiple($related_hub_ids);
        // Prepare a render array.
        $hubs = array(
          '#theme_wrappers' => array('cluster_og_related_hubs'),
          '#total' => count($hub_nodes),
        );

        // Add node render arrays.
        foreach ($hub_nodes as $hub_node) {
          $hubs[$hub_node->nid] = node_view($hub_node, 'teaser'); //TODO: change teaser to custom view mode
        }
        $node->content['related_hubs'] = $hubs;
      }

      // Make a list of responses associated to this region and to its descendants.
      if ($descendant_response_ids) {
        $response_nodes = node_load_multiple($descendant_response_ids);
        // Prepare a render array.
        $responses = array(
          '#theme_wrappers' => array('cluster_og_related_responses'),
          '#total' => count($response_nodes),
        );

        // Add node render arrays.
        foreach ($response_nodes as $response_node) {
          $responses[$response_node->nid] = node_view($response_node, 'teaser'); //TODO: change teaser to custom view mode
        }
        $node->content['related_responses'] = $responses;
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function cluster_og_node_insert($node) {
  // Clear the menu cache to add the new region to the menu.
  if ($node->type == 'geographic_region') {
    menu_rebuild();
  }
}

/**
 * Theme API.
 */

/**
 * Implements hook_theme().
 */
function cluster_og_theme() {
  return array(
    'cluster_og_contact_member' => array(
      'file' => 'theme/cluster_og.theme.inc',
      'render element' => 'element',
    ),
    'cluster_og_related_responses' => array(
      'file' => 'theme/cluster_og.theme.inc',
      'render element' => 'element',
    ),
    'cluster_og_related_hubs' => array(
      'file' => 'theme/cluster_og.theme.inc',
      'render element' => 'element',
    ),
  );
}

/**
 * Implements hook_preprocess_page().
 */
function cluster_og_preprocess_page(&$vars) {
  module_load_include('inc', 'cluster_og', 'theme/cluster_og.theme');
  _cluster_og_preprocess_page($vars);
}

/**
 * Implements hook_preprocess_field().
 */
function cluster_og_preprocess_field(&$vars) {
  module_load_include('inc', 'cluster_og', 'theme/cluster_og.theme');
  _cluster_og_preprocess_field($vars);
}

/**
 * Helpers.
 */

/**
 * Recursively get all the descendants for the argued regions.
 * @param $nids
 *  Array of entity ids from which to perform the search.
 * @param $include_self
 *  Whether to include the given ids in the response.
 * @param $collected_nids
 *  Recursively aggregate node ids.
 * @return
 *  Array of node ids representing the set of all descendants for the given regions.
 */
function _cluster_og_get_region_descendants($nids, $include_self = FALSE, $collected_nids = array()) {
  if (!is_array($nids)) {
    $nids = array($nids);
  }

  if ($include_self) {
    $collected_nids = array_unique(array_merge($nids, $collected_nids));
  }

  // Recursively look for regions that have any of the argued $nids for parent.
  $query = new EntityFieldQuery();
  $res = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'geographic_region')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_parent_region', 'target_id', $nids, 'IN')
    ->execute();

  if (isset($res['node'])) {
    $res_nids = array_keys($res['node']);
    $collected_nids = array_unique(array_merge($res_nids, $collected_nids));
    return _cluster_og_get_region_descendants($res_nids, TRUE, $collected_nids);
  }

  return $collected_nids;
}

/**
 * Recursively get all the descendants for the argued responses.
 * @param $nids
 *  Array of entity ids from which to perform the search.
 * @param $include_self
 *  Whether to include the given ids in the response.
 * @param $collected_nids
 *  Recursively aggregate node ids.
 * @return
 *  Array of node ids representing the set of all descendants for the given responses.
 */
function _cluster_og_get_response_descendants($nids, $include_self = FALSE, $collected_nids = array()) {
  if (!is_array($nids)) {
    $nids = array($nids);
  }

  if ($include_self) {
    $collected_nids = array_unique(array_merge($nids, $collected_nids));
  }

  // Recursively look for responses that have any of the argued $nids for parent.
  $query = new EntityFieldQuery();
  $res = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'response')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_parent_response', 'target_id', $nids, 'IN')
    ->execute();

  if (isset($res['node'])) {
    $res_nids = array_keys($res['node']);
    $collected_nids = array_unique(array_merge($res_nids, $collected_nids));
    return _cluster_og_get_response_descendants($res_nids, TRUE, $collected_nids);
  }

  return $collected_nids;
}

/**
 * Get all responses for a set of regions.
 * @param $nids
 *  Array of region node ids.
 * @return
 *  Array of all responses that are associated to any of the argued region ids.
 */
function _cluster_og_get_region_responses($nids) {
  if (!is_array($nids)) {
    $nids = array($nids);
  }

  $query = new EntityFieldQuery();
  $res = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'response')
    ->fieldCondition('field_associated_regions', 'target_id', $nids, 'IN')
    ->execute();

  $response_ids = isset($res['node']) ? array_keys($res['node']) : array();
  return $response_ids;
}

/**
 * Get all hubs for a set of regions.
 * @param $nids
 *  Array of region node ids.
 * @return
 *  Array of all hubs that are associated to any of the argued region ids.
 */
function _cluster_og_get_region_hubs($nids) {
  if (!is_array($nids)) {
    $nids = array($nids);
  }

  $query = new EntityFieldQuery();
  $res = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'hub')
    ->fieldCondition('field_parent_region', 'target_id', $nids, 'IN')
    ->execute();

  $hub_ids = isset($res['node']) ? array_keys($res['node']) : array();
  return $hub_ids;
}

/**
 * Get all hubs for a set of responses.
 * @param $nids
 *  Array of response node ids.
 * @return
 *  Array of all hubs that are associated to any of the argued response ids.
 */
function _cluster_og_get_response_hubs($nids) {
  if (!is_array($nids)) {
    $nids = array($nids);
  }

  $query = new EntityFieldQuery();
  $res = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'hub')
    ->fieldCondition('field_parent_response', 'target_id', $nids, 'IN')
    ->execute();

  $hub_ids = isset($res['node']) ? array_keys($res['node']) : array();
  return $hub_ids;
}

/**
 * Get the role id for a group from the role name.
 * @param $bundle,
 *  Group entity bundle name.
 * @param $role_name
 *  The role name as stored in the database.
 */
function _cluster_og_get_role_id_by_name($bundle, $role_name) {
  return db_select('og_role', 'og_r')
    ->fields('og_r', array('rid'))
    ->condition('group_bundle', $bundle)
    ->condition('name', $role_name)
    ->execute()->fetchField();
}

/**
 * Get all users with specified role for a group.
 * @param $gid
 *  Group id.
 * @param $rid
 *  OG role id.
 * @return
 *  array of user ids.
 */
function _cluster_og_get_group_users_by_role($gid, $rid) {
  return db_select('og_users_roles', 'og_ur')
    ->fields('og_ur', array('uid'))
    ->condition('gid', $gid)
    ->condition('rid', $rid)
    ->execute()->fetchCol();
}

/**
 * Returns render array for a given menu.
 * @param $menu_name
 *  Machine name of the required menu.
 * @param $current_page_only
 *  If TRUE menu is only expended for the currently viewed page / path.
 *  If FALSE the whole menu tree is provided.
 * @return
 *  Regions menu render array.
 */
function _cluster_og_get_regions_menu($menu_name, $current_page_only = TRUE) {
  if ($current_page_only) {
    $tree = menu_tree_page_data($menu_name, NULL, TRUE);
  }
  else {
    $tree = menu_tree_all_data($menu_name); 
  }
  $output = menu_tree_output($tree);
  return $output;
}

/**
 * Generate path for a Geographic region group by prefixing all parents and ancestors labels
 * to the group label.
 * @param $wrapper
 *  Entity metadata wrapper.
 * @param $path
 *  Recursively obtained path for previous wrappers in the hierarchy.
 * @return
 *  Path string to a geographic_region entity that includes the label of all parent and ancestor geographic_region,
 *  such as asia/philippines/manilla.
 */
function _cluster_og_generate_region_path($wrapper, $path = '') {
  $path = strtolower($wrapper->label() . '/' . $path);
  if ($wrapper->field_parent_region->value()) {
    return _cluster_og_generate_region_path($wrapper->field_parent_region, $path);
  }
  return trim($path, '/');
}