<?php
/**
 * @file
 * Code for the cluster_discussions feature.
 */

include_once 'cluster_discussions.features.inc';
include_once 'cluster_discussions.pathauto.inc';

const CLUSTER_DISCUSSIONS_PER_PAGE = 5;

/**
 *  Implements hook_menu().
 */
function cluster_discussions_menu() {
  $items['node/%/discussions'] = array(
    'title' => 'Discussions',
    'title callback' => '_cluster_discussions_title_callback',
    'title arguments' => array(1),
    'page callback' => 'cluster_discussions_all',
    'page arguments' => array(1),
    'access callback' => 'og_is_group',
    'access arguments' => array(0, 1),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Menu title callback.
 */
function _cluster_discussions_title_callback($nid) {
  global $language;
  $title = t('Discussions');
  if (! is_numeric($nid)) {
    return $title;
  }

  try {
    // @TODO manage multilingual loading of entities.
    $wrapper = entity_metadata_wrapper('node', node_load($nid), array('langcode' => LANGUAGE_NONE));
    return $wrapper->label();
  }
  catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cluster_discussions',
      'See '  . __FUNCTION__ . '() ' .  $exc->getTraceAsString(),
       NULL,
       WATCHDOG_ERROR
    );
  }
  return $title;
}

/**
 * Page callback, shows a group's discussions using Search API.
 * @param $nid
 * @return Render array
 */
function cluster_discussions_all($nid) {
  global $language;
  $query = search_api_query('default_node_index', array(
    'languages' => array($language->language),
  ));

  $filter = $query->createFilter();
  $filter->condition('og_group_ref', $nid);
  $filter->condition('type', 'discussion');
  $query->filter($filter);

  $query->sort('changed', 'DESC');

  $offset = pager_find_page() * CLUSTER_DISCUSSIONS_PER_PAGE;
  $query->range($offset, CLUSTER_DISCUSSIONS_PER_PAGE);

  $result = $query->execute();
  pager_default_initialize($result['result count'], CLUSTER_DISCUSSIONS_PER_PAGE);
  if (! $result['results']) {
    $content = array(
      '#markup' => t('No content for the moment.'),
    );
  }
  else {
    $content = node_view_multiple(node_load_multiple(array_keys($result['results'])));
  }
  $ret['content'] = $content;
  $ret['pager'] = array(
    '#theme' => 'pager',
  );

  return $ret;
}

/**
 * Implements hook_theme().
 */
function cluster_discussions_theme() {
  return array(
    'cluster_discussions_all' => array(
      'file' => 'theme/cluster_discussions.theme.inc',
      'render element' => 'element',
    ),
    'cluster_discussions_teaser' => array(
      'file' => 'theme/cluster_discussions.theme.inc',
      'render element' => 'element',
    ),
    'cluster_discussions_email' => [
      'template' => 'discussion-email',
      'variables' => [
        'langcode' => '',
        'logo' => '',
        'date' => '',
        'body' => '', // html string
        'group' => [],
        'node' => [],
      ],
      'path' => drupal_get_path('module', 'cluster_discussions') . '/templates',
    ],
    'cluster_discussions_email_comment' => [
      'template' => 'comment-email',
      'variables' => [
        'langcode' => '',
        'logo' => '',
        'date' => '',
        'body' => '', // html string
        'group' => [],
        'node' => [],
        'comment' => [],
      ],
      'path' => drupal_get_path('module', 'cluster_discussions') . '/templates',
    ],
  );
}

/**
 * Implements hook_node_view_alter().
 */
function cluster_discussions_node_view_alter(&$build) {
  if ($build['#node']->type != 'discussion') {
    return;
  }
  switch ($build['#view_mode']) {
    case 'teaser':
      $build['#theme'] = 'cluster_discussions_teaser';
      if (!$build['#node']->comment_count) {
        $build['#replies'] = t('no replies');
      }
      else {
        $build['#replies'] = format_plural($build['#node']->comment_count, '1 reply', '@count replies');
      }

      $build['#is_latest'] = FALSE;
      $gid = _cluster_discussion_associated_group($build['#node']->nid);
      if ($gid) {
        $build['#is_latest'] = $build['#node']->nid == _cluster_discussion_get_latest($gid);
      }

      // Author
      $user = user_load($build['#node']->uid);
      $build['#author'] = array(
        'name' => $user->name,
        'path' => 'user/'.$user->uid,
      );
      break;
    default:
      // Do nothing.
  }
}

/**
 * Gets the associated group ID for the given discussion node ID, if any.
 * @param $nid
 * @return int|NULL
 */
function _cluster_discussion_associated_group($nid) {
  return db_select('og_membership', 'g')
    ->fields('g', array('gid'))
    ->condition('g.entity_type', 'node')
    ->condition('g.group_type', 'node')
    ->condition('g.etid', $nid)
    ->execute()->fetchField();
}

/**
 * Get the latest discussion nid for the given group, if any.
 * @param $gid
 * @return int|NULL
 */
function _cluster_discussion_get_latest($gid) {
  if (!og_is_group('node', node_load($gid))) {
    return;
  }

  $query = db_select('og_membership', 'g');

  $query->fields('g', array('etid'));

  $query->join('node', 'n', 'n.nid = g.etid');
  $query->condition('g.entity_type', 'node');

  $query->condition('g.group_type', 'node');
  $query->condition('g.gid', $gid);

  $query->condition('n.type', 'discussion');
  $query->condition('n.status', NODE_PUBLISHED);

  $query->orderBy('g.created', 'DESC');
  $query->range(0, 1);

  return $query->execute()->fetchField();
}

/**
 * Implements hook_comment_insert().
 * Save the node to make its "changed" value update, so that we're able to sort
 * by "last activity".
 */
function cluster_discussions_comment_insert($comment) {
  $node = node_load($comment->nid);
  if ($node->type !== 'discussion')
    return;
  node_save($node);
}

/**
 * Implements hook_mail().
 */
function cluster_discussions_mail($key, &$message, $params) {
  if (!in_array($key, ['discussion', 'comment']))
    throw new Exception("Unknown key: ".$key);

  $is_comment = $key === 'comment';

  $body = [
    '#theme' => $is_comment ? 'cluster_discussions_email_comment' : 'cluster_discussions_email',
    '#logo' => url('sites/all/themes/shelter/assets/svg/replacement/logo-global-shelter-cluster-4x.png', ['absolute' => TRUE]),
    '#langcode' => $params['langcode'],
    '#date' => $params['date'],
    '#body' => $params['body'],
    '#group' => $params['group'],
    '#node' => $params['node'],
  ];
  if ($is_comment)
    $body['#comment'] = $params['comment'];

//  // E.g. "Ecuador Earthquake 2016 (response)"
//  $group_name = cluster_api_group_notification_title($params['group'], $params['langcode']);
  $group_name = $params['group']->title;

  if ($is_comment)
    $message['subject'] = 'Re: ' . $group_name . ' — ' . $params['node']->title;
  else
    $message['subject'] = $group_name . ' — ' . $params['node']->title;
  //  $message['subject'] = $params['node']->title;
  $message['from_name'] = $is_comment
    ? $params['comment']->registered_name
    : $params['node']->name;
  $message['body'] = [drupal_render($body)];

  $reply_to_address = cluster_email_inbound_address('comment-'.$params['node']->nid);
  $message['headers']['Reply-To'] = $reply_to_address;
}

/**
 * Implements hook_cron().
 */
function cluster_discussions_cron() {
  // Email notifications for new discussion nodes

  $query = new EntityFieldQuery();
  $results = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'discussion')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_is_sent', 'value', '1', '<>')

    // Just in case, don't send if it's more than a week old
    ->propertyCondition('created', REQUEST_TIME - (7*CLUSTER_API_DAY), '>')

    ->propertyOrderBy('created', 'ASC')

    ->execute();

  $nids = $results && $results['node'] ? array_keys($results['node']) : [];

  foreach (node_load_multiple($nids) as $discussion_node) {
    $discussion_wrapper = entity_metadata_wrapper('node', $discussion_node);

    $discussion_wrapper->field_is_sent->set(1);
    $discussion_wrapper->save();

    $body = $discussion_wrapper->body->value()['safe_value'];
    $discussion_date = $discussion_node->created;

    $all_uids = []; // Unified list of uids for all the groups to which this discussion item belongs.
    $first_group = NULL;

    foreach ($discussion_wrapper->og_group_ref->value() as $group) {
      if (!og_is_group('node', $group))
        continue; // shouldn't happen
      $manager = GroupContentManager::getInstance($group);
      if (is_null($first_group))
        $first_group = $group;

      $all_uids = array_unique(array_merge($all_uids, cluster_api_get_followers($manager)));
    }

    // Don't email the author
    $all_uids = array_values(array_diff($all_uids, [$discussion_node->uid]));

    if (!$all_uids)
      continue;

    foreach (cluster_api_split_users_by_langcode($all_uids) as $langcode => $uids) {
      try {
        $params = [
          'node' => $discussion_node,
          'group' => $first_group,
          'date' => $discussion_date,
          'body' => $body,
          'langcode' => $langcode,
        ];
        $to = _cluster_email_recipients_string($uids);

        drupal_mail('cluster_discussions', 'discussion', $to, $langcode, $params);
      } catch (Exception $e) {
        watchdog('cluster_discussions', 'Error sending discussion email @nid: @error', [
          '@nid' => $discussion_node->nid,
          '@error' => $e->getMessage(),
        ], WATCHDOG_ERROR);
      }
    }
  }

  // Email notifications for new comments on discussions

  $query = new EntityFieldQuery();
  $results = $query->entityCondition('entity_type', 'comment')

  /**
   * This doesn't work, but it's fine as long as we're only using comments
   * mostly for discussion nodes. There's a check below that filters out other
   * comment types.
   */
//    ->propertyCondition('node_type', 'comment_node_discussion')

    ->propertyCondition('status', COMMENT_PUBLISHED)
    ->propertyCondition('is_sent', 1, '<>') // from the cluster_comment module

    // Just in case, don't send if it's more than a week old
    ->propertyCondition('created', REQUEST_TIME - (7*CLUSTER_API_DAY), '>')

    ->propertyOrderBy('created', 'ASC')

    ->execute();

  $cids = $results && $results['comment'] ? array_keys($results['comment']) : [];

  foreach (comment_load_multiple($cids) as $comment) {
    if ($comment->node_type !== 'comment_node_discussion')
      continue;
    $discussion_node = node_load($comment->nid);
    if ($discussion_node->type !== 'discussion' || $discussion_node->status != NODE_PUBLISHED)
      continue;

    $comment_wrapper = entity_metadata_wrapper('comment', $comment);
    $discussion_wrapper = entity_metadata_wrapper('node', $discussion_node);

    $comment->is_sent = 1;
    comment_save($comment);

    $body = $comment_wrapper->comment_body->value()['safe_value'];
    $comment_date = $comment->created;

    $all_uids = []; // Unified list of uids for all the groups to which this discussion item belongs.
    $first_group = NULL;

    foreach ($discussion_wrapper->og_group_ref->value() as $group) {
      if (!og_is_group('node', $group))
        continue; // shouldn't happen
      $manager = GroupContentManager::getInstance($group);
      if (is_null($first_group))
        $first_group = $group;

      $all_uids = array_unique(array_merge($all_uids, cluster_api_get_followers($manager)));
    }

    // Don't email the author
    $all_uids = array_values(array_diff($all_uids, [$comment->uid]));

    if (!$all_uids)
      continue;

    foreach (cluster_api_split_users_by_langcode($all_uids) as $langcode => $uids) {
      try {
        $params = [
          'comment' => $comment,
          'node' => $discussion_node,
          'group' => $first_group,
          'date' => $comment_date,
          'body' => $body,
          'langcode' => $langcode,
        ];
        $to = _cluster_email_recipients_string($uids);

dpm(['cluster_discussions', 'comment', $to, $langcode, $params], 'to be sent!');
        drupal_mail('cluster_discussions', 'comment', $to, $langcode, $params);
      } catch (Exception $e) {
        watchdog('cluster_discussions', 'Error sending discussion comment email @nid: @error', [
          '@cid' => $comment->cid,
          '@error' => $e->getMessage(),
        ], WATCHDOG_ERROR);
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function cluster_discussions_form_comment_form_alter(&$form, &$form_state) {
  $form['author']['#access'] = FALSE;
}

/**
 * Implements hook_preprocess_HOOK().
 */
function cluster_discussions_preprocess_comment(&$variables) {
  // These lines make the date show as "time ago", but this doesn't work for anonymous users because of page caching.
//  $created = new DateObject($variables['comment']->created);
//  $variables['created'] = theme('date_time_ago', ['start_date' => $created, 'end_date' => $created]);

  if (!isset($variables['content']['links']) || !isset($variables['content']['links']['comment']))
    return;

  // Never show "reply" link
  if (isset($variables['content']['links']['comment']['#links']['comment-reply']))
    unset($variables['content']['links']['comment']['#links']['comment-reply']);

  // Change "Edit" and "Delete" links to icons
  if (isset($variables['content']['links']['comment']['#links']['comment-delete']))
    $variables['content']['links']['comment']['#links']['comment-delete']['title'] = '<i class="fa fa-trash" title="'.t('Delete').'"></i>';

  if (isset($variables['content']['links']['comment']['#links']['comment-edit']))
    $variables['content']['links']['comment']['#links']['comment-edit']['title'] = '<i class="fa fa-edit" title="'.t('Edit').'"></i>';
}

/**
 * Implements hook_cluster_email_inbound_handle().
 */
function cluster_discussions_cluster_email_inbound_handle($name, $message) {
  $prefix_discussion = 'discussion-';
  $prefix_comment = 'comment-';
  if (
    substr($name, 0, strlen($prefix_discussion)) !== $prefix_discussion
    && substr($name, 0, strlen($prefix_comment)) !== $prefix_comment
  ) {
    // This is an optimization to return quickly without expensive regex operations.
    return;
  }

  if (preg_match('/^' . preg_quote($prefix_discussion) . '(\d+)$/', $name, $matches)) {
    _cluster_discussions_inbound_discussion($matches[1], $message);
  }
  elseif (preg_match('/^' . preg_quote($prefix_comment) . '(\d+)$/', $name, $matches)) {
    _cluster_discussions_inbound_comment($matches[1], $message);
  }
}

/**
 * Add a new discussion to the given group (from an inbound email).
 *
 * @param int $group_nid
 * @param array $message
 */
function _cluster_discussions_inbound_discussion($group_nid, $message) {
  $group = node_load($group_nid);
  if (!og_is_group('node', $group)) {
    return;
  }

  $values = [
    'type' => 'discussion',
    'created' => $message['ts'],
    'status' => NODE_PUBLISHED,
    'title' => trim($message['subject']),
  ];

  $user = NULL;
  $language = 'en';
  if (isset($message['uid']) && $user = user_load($message['uid'])) {
    $values['uid'] = $user->uid;

    $language = $user->language;
    $values['language'] = $language;
  }

  if (!$values['title']) {
    $values['title'] = t('New discussion', [], ['langcode' => $language]);
  }

  $discussion = entity_create('node', $values);
  $wrapper = entity_metadata_wrapper('node', $discussion);

  if (isset($message['html'])) {
    $wrapper->body->set([
      'value' => $message['html'],
      'format' => 'filtered_html'
    ]);
  }
  else {
    $wrapper->body->set([
      'value' => $message['text'],
      'format' => 'plain_text'
    ]);
  }

  $wrapper->og_group_ref->set([$group]);

  $wrapper->save();

  watchdog('cluster_discussions', 'Created discussion @nid on group @gid from inbound email: @title', [
    '@gid' => $group_nid,
    '@nid' => $wrapper->nid->value(),
    '@title' => $values['title'],
  ]);
}

/**
 * Add a new comment to a discussion (from an inbound email).
 *
 * @param int $discussion_nid
 * @param array $message
 */
function _cluster_discussions_inbound_comment($discussion_nid, $message) {
  $discussion = node_load($discussion_nid);
  if (!$discussion || $discussion->type !== 'discussion') {
    return;
  }

  $values = [
    'created' => $message['ts'],
    'nid' => $discussion->nid,
    'status' => COMMENT_PUBLISHED,
    'node_type' => 'comment_node_discussion',
  ];

  if (isset($message['html'])) {
    $values['subject'] = text_summary(strip_tags($message['html']), 'plain_text', 60);
  }
  else {
    $values['subject'] = text_summary($message['text'], 'plain_text', 60);
  }

  $user = NULL;
  if (isset($message['uid']) && $user = user_load($message['uid'])) {
    $values['uid'] = $user->uid;
  }

  $comment = entity_create('comment', $values);
  $wrapper = entity_metadata_wrapper('comment', $comment);

  if (isset($message['html'])) {
    $wrapper->comment_body->set([
      'value' => $message['html'],
      'format' => 'filtered_html'
    ]);
  }
  else {
    $wrapper->comment_body->set([
      'value' => $message['text'],
      'format' => 'plain_text'
    ]);
  }

  $wrapper->save();

  watchdog('cluster_discussions', 'Created comment @cid on discussion @nid from inbound email', [
    '@cid' => $wrapper->cid->value(),
    '@nid' => $discussion->nid,
  ]);
}
