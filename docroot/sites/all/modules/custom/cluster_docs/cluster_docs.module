<?php
/**
 * @file
 * Code for the cluster_docs feature.
 */

include_once 'cluster_docs.features.inc';
include_once 'cluster_docs.admin.inc';
include_once 'cluster_docs.pathauto.inc';

const CLUSTER_DOCS_PER_PAGE = 30;

/**
 *  Implements hook_menu().
 */
function cluster_docs_menu() {
  $items['node/%/documents'] = array(
    'title' => 'Documents',
    'page callback' => 'cluster_docs_all',
    'page arguments' => array(1),
    'access callback' => 'og_is_group',
    'access arguments' => array(0, 1),
    'title callback' => '_cluster_docs_title_callback',
    'title arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
  $items['references'] = array(
    'title' => 'References',
    'menu_name' => 'main-menu',
    'page callback' => 'cluster_docs_reference',
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Menu title callback.
 */
function _cluster_docs_title_callback($nid) {
  global $language;
  $title = t('Documents');
  if (! is_numeric($nid)) {
    return $title;
  }

  try {
    // @TODO manage multilinigual loading of entities.
    $wrapper = entity_metadata_wrapper('node', node_load($nid), array('langcode' => LANGUAGE_NONE));
    return $wrapper->label() . ' - ' . $title;
  }
  catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cluster_docs',
      'See '  . __FUNCTION__ . '() ' .  $exc->getTraceAsString(),
       NULL,
       WATCHDOG_ERROR
    );
  }
  return $title;
}

/**
 * Page callback, shows a group's documents using Search API.
 * @param $nid
 * @return Render array
 */
function cluster_docs_all($nid) {
  $node = node_load($nid);

  global $language;
  $query = search_api_query('default_node_index', array(
//    'languages' => array($language->language),
  ));

  $title = NULL;
  // Read the title filter value from the URL, if it exists.
  if (isset($_GET['f']) && is_array($_GET['f'])) {
    foreach ($_GET['f'] as $filter) {
      if (substr($filter, 0, 6) == 'title:') {
        $title = substr($filter, 6);
      }
    }
  }

  $filter = $query->createFilter();
  $filter->condition('og_group_ref', $nid);
  $filter->condition('type', 'document');
  $query->filter($filter);

  $offset = pager_find_page() * CLUSTER_DOCS_PER_PAGE;
  $query->range($offset, CLUSTER_DOCS_PER_PAGE);

  $results = $query->execute();

  pager_default_initialize($results['result count'], CLUSTER_DOCS_PER_PAGE);

  $nids = array_keys($results['results']);

  $reset_link = FALSE;
  if (isset($_GET['f'])) {
    //TODO: improve detection
    $reset_link = array(
      '#theme' => 'link',
      '#text' => 'reset filters',
      '#path' => 'node/' . $nid . '/documents',
      '#options' => array(
        'attributes' => array('class' => 'reset-filters'),
      ),
    );
  }

  $facets = array();

  // Define which facets to show and in what order.
  $facets_to_show = array(
    'field_document_type',

    // Basic tags
    'field_coordination_management',
    'field_information_management',
    'field_technical_support_design',

    // Advanced tags
    'field_assess_monitor_eval',
    'field_inter_cluster',
    'field_cross_cutting_issues',
    'field_response_phase',
    'field_intervention_materials',
    'field_intervention_programming',
    'field_settlement_type',
    'field_non_food_items',
    'field_issues',
    'field_toolkit',

    // Disabled facets
//    'og_group_ref',
  );

  foreach (facetapi_get_block_info(array('block')) as $delta => $info) {
    $block_view = module_invoke('facetapi', 'block_view', $delta);
    if (is_null($block_view)) {
      continue;
    }
    $content = $block_view['content'];

    $facet = $content['#settings']->facet;
    if (!in_array($facet, $facets_to_show)) {
      continue;
    }

    $content['#options'] = $content[$facet];
//    if (count($content['#options']['#items']) < 2) {
//      // Don't show facets with only one option.
//      continue;
//    }

    $content['#theme'] = 'cluster_docs_facet';
    $content['#weight'] = array_search($facet, $facets_to_show);

    $facets[$delta] = $content;
  }

  $facets[] = array(
    '#weight' => -50,
    '#theme' => 'cluster_docs_facet',
    '#title' => 'Title Contains',
    '#options' => FALSE,
    '#child' => array(
      '#type' => 'textfield',
      '#name' => 'title',
      '#value' => $title,
    ),
  );
  drupal_add_js(drupal_get_path('module', 'cluster_docs') . '/js/search.js');

  $ret = array(
    array(
      '#theme' => 'cluster_docs_table_list',
      '#heading' => t('Documents') . ' (' . $results['result count'] . ')',
      '#docs' => cluster_docs_prepare_row_data($nids),
      '#reset_link' => $reset_link ? render($copy = $reset_link) : NULL,
    ),
    'pager' => array('#theme' => 'pager'),
    'side-column' => array(
      '#prefix' => '<section class="facets">',
      '#suffix' => '</section>',
      'facets' => $facets,
      'reset_link' => $reset_link,
    ),
  );

  return $ret;
}

/**
 * Page callback, shows all reference documents using Search API.
 * @return Render array
 */
function cluster_docs_reference() {
  global $language;
  $query = search_api_query('default_node_index', array(
    'languages' => array($language->language),
  ));

  $filter = $query->createFilter();
  $filter->condition('field_is_reference_document', TRUE);
  $filter->condition('type', 'document');
  $query->filter($filter);

  $offset = pager_find_page() * CLUSTER_DOCS_PER_PAGE;
  $query->range($offset, CLUSTER_DOCS_PER_PAGE);

  $results = $query->execute();

  pager_default_initialize($results['result count'], CLUSTER_DOCS_PER_PAGE);

  $nids = array_keys($results['results']);

  $ret = array(
    array(
      '#theme' => 'cluster_docs_cards_list',
      '#heading' => t('Reference documents'),
      '#docs' => cluster_docs_prepare_card_data($nids),
    ),
    'pager' => array('#theme' => 'pager'),
  );

  return $ret;
}

/**
 *  Get all key docs for a group, grouped by category.
 * @param $gid
 *  Group node id.
 * @return
 *  Renderable array of documents grouped by vocabulary and displayed as cards.
 */
function cluster_docs_get_grouped_key_docs($gid) {
  // Use the field_group module API to generate a list of categories.
  $info = field_group_info_groups('node', 'document', 'form', TRUE);
  $basic_tag_fields = $info['group_basic_tags']->children;
  $advanced_tag_fields = $info['group_advanced_tags']->children;
  $categories = array_merge($basic_tag_fields, $advanced_tag_fields);

  $grouped_docs = array();
  foreach ($categories as $category_field) {
    $query = new EntityFieldQuery();
    $res = $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'document')
      ->fieldCondition('og_group_ref', 'target_id', $gid)
      ->fieldCondition('field_featured', 'value', 1, '!=')
      ->fieldCondition('field_key_document', 'value', 1)
      ->fieldCondition($category_field, 'tid', 'NULL', '!=')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->execute();

    if (isset($res['node'])) {
      // Get the vocabulary associated with this field.
      $info = field_info_field($category_field);
      $vocab_machine_name = $info['settings']['allowed_values'][0]['vocabulary'];
      $vocab = taxonomy_vocabulary_machine_name_load($vocab_machine_name);
      $grouped_docs[] = array(
        '#theme' => 'cluster_docs_cards_list',
        '#heading' => $vocab->name,
        '#docs' => cluster_docs_prepare_card_data(array_keys($res['node'])),
      );
    }
  }
  return $grouped_docs;
}

/**
 * Prepare the data for document cards.
 * @param $nids
 *  Document node ids.
 * @return
 *  Array of document data ready to be used in cards lists.
 */
function cluster_docs_prepare_card_data($nids) {
  $docs = array();
  $properties = array('title', 'link', 'link_url', 'is_link', 'is_file', 'is_file_class', 'description', 'filesize',
    'file_extension', 'is_image', 'image_uri', 'has_preview', 'preview_uri', 'source',);

  // @TODO language negocitation.
  global $language;
  $langcode = $language->language;
  foreach (node_load_multiple($nids) as $node) {
    // Set default values.
    $doc = array_fill_keys($properties, FALSE);
    try {

      // @TODO insert language negociation in info array.
      $wrapper = entity_metadata_wrapper('node', $node);
      $doc['title'] = $wrapper->label();

      if ($file = $wrapper->field_file->value()) {
        $url = file_create_url($file['uri']);
      }
      else {
        $url = $wrapper->field_link->url->value();
      }
      $doc['link_url'] = $url;
      $doc['link'] = l($doc['title'], $url, array('attributes' => array('target' => '_blank')));

      // Prepare the description.
      $desc = '';
      if ($body = $wrapper->body->value()) {
        // Use user supplied summary if available.
        if($body['safe_summary']) {
          $desc = $body['safe_summary'];
        }
        // Create summary.
        elseif ($body['safe_value']) {
          $alter = array(
            // @TODO get this value from the body field settings.
            'max_length' => 100,
            'ellipsis' => TRUE,
            'word_boundary' => TRUE,
            'html' => TRUE,
          );
          $desc = views_trim_text($alter, $body['safe_value']);
        }
      }
      $doc['description'] = $desc;

      // Test if this document is a file field.
      if ($file = $wrapper->field_file->value()) {
        $doc['is_file'] = TRUE;
        $doc['is_file_class'] = '';
        if ($doc['is_file']) {
          $doc['is_file_class'] = 'local-file';
        }

        $file_extension = pathinfo($file['filename'], PATHINFO_EXTENSION);
        $doc['file_extension'] = l($file_extension, $url, array('attributes' => array('target' => '_blank')));

        // Test if the attached file is an image.
        // @TODO the image file will probably not be the actual document file.
        switch ($file_extension) {
          case 'png':
          case 'jpg':
          case 'gif':
            $doc['is_image'] = TRUE;
            $doc['image_uri'] = $file['uri'];
            break;
        }
        $doc['filesize'] = number_format($file['filesize'] / 1048576, 2);
      }

      // Test if this document has a preview image.
      if ($file = $wrapper->field_preview->value()) {
        $doc['has_preview'] = TRUE;
        $doc['preview_uri'] = $file['uri'];
      }

      // Test if this document is a link field.
      if ($link = $wrapper->field_link->value()) {
        $doc['is_link'] = TRUE;
      }

      // Set the source value.
      if ($source = $wrapper->field_document_source->value()) {
        $doc['source'] = $source;
      }

      $docs[] = $doc;

    }
    catch (EntityMetadataWrapperException $exc) {
      watchdog(
        'cluster_docs',
        'See '  . __FUNCTION__ . '() ' .  $exc->getTraceAsString(),
         NULL,
         WATCHDOG_ERROR
      );
    }
  }
  return $docs;
}

/**
 * Prepare the data for document table rows.
 * @param $nids
 *  Document node ids.
 * @return
 *  Array of document data ready to be used in cards lists.
 */
function cluster_docs_prepare_row_data($nids) {
  $docs = array();
  $properties = array('title', 'link', 'link_url', 'is_link', 'is_file', 'is_file_class', 'description', 'filesize',
    'file_extension', 'is_image', 'image_uri', 'has_preview', 'preview_uri', 'source',);

  // @TODO language negocitation.
  global $language;
  $langcode = $language->language;
  foreach (node_load_multiple($nids) as $node) {
    // Set default values.
    $doc = array_fill_keys($properties, FALSE);
    try {

      // @TODO insert language negociation in info array.
      $wrapper = entity_metadata_wrapper('node', $node);
      $doc['title'] = $wrapper->label();

      if ($file = $wrapper->field_file->value()) {
        $url = file_create_url($file['uri']);
      }
      else {
        $url = $wrapper->field_link->url->value();
      }
      $doc['link_url'] = $url;
      $doc['link'] = l($doc['title'], $url, array('attributes' => array('target' => '_blank')));

      // Prepare the description.
      $desc = '';
      if ($body = $wrapper->body->value()) {
        // Use user supplied summary if available.
        if($body['safe_summary']) {
          $desc = $body['safe_summary'];
        }
        // Create summary.
        elseif ($body['safe_value']) {
          $alter = array(
            // @TODO get this value from the body field settings.
            'max_length' => 100,
            'ellipsis' => TRUE,
            'word_boundary' => TRUE,
            'html' => TRUE,
          );
          $desc = views_trim_text($alter, $body['safe_value']);
        }
      }
      $doc['description'] = $desc;

      // Test if this document is a file field.
      if ($file = $wrapper->field_file->value()) {
        $doc['is_file'] = TRUE;
        $doc['is_file_class'] = '';
        if ($doc['is_file']) {
          $doc['is_file_class'] = 'local-file';
        }

        $file_extension = pathinfo($file['filename'], PATHINFO_EXTENSION);
        $doc['file_extension'] = l($file_extension, $url, array('attributes' => array('target' => '_blank')));

        // Test if the attached file is an image.
        // @TODO the image file will probably not be the actual document file.
        switch ($file_extension) {
          case 'png':
          case 'jpg':
          case 'gif':
            $doc['is_image'] = TRUE;
            $doc['image_uri'] = $file['uri'];
            break;
        }
        $doc['filesize'] = number_format($file['filesize'] / 1048576, 2);
      }

      // Test if this document has a preview image.
      if ($file = $wrapper->field_preview->value()) {
        $doc['has_preview'] = TRUE;
        $doc['preview_uri'] = $file['uri'];
      }

      // Test if this document is a link field.
      if ($link = $wrapper->field_link->value()) {
        $doc['is_link'] = TRUE;
      }

      // Set the publication date.
      $doc['publication_date'] = format_date($node->created, 'custom', 'Y/m/d');

      $docs[] = $doc;

    }
    catch (EntityMetadataWrapperException $exc) {
      watchdog(
        'cluster_docs',
        'See '  . __FUNCTION__ . '() ' .  $exc->getTraceAsString(),
         NULL,
         WATCHDOG_ERROR
      );
    }
  }
  return $docs;
}

/**
 * Implements hook_permission().
 */
function cluster_docs_permission() {
  return array(
    'view document full node' => array(
      'title' => t('View documents full view mode.'),
      'description' => t('Access document nodes in full page view mode.'),
    ),
  );
}

/**
 * Implements hook_node_view().
 */
function cluster_docs_node_view($node, $view_mode) {
  if ($node->type == 'document' && $view_mode == 'full' && ! user_access('view document full node')) {
    drupal_access_denied();
  }
}

/**
 * Implements hook_theme().
 */
function cluster_docs_theme() {
  return array(
    'cluster_docs_all' => array(
      'file' => 'theme/cluster_docs.theme.inc',
      'render element' => 'element',
    ),
    'cluster_docs_cards_list' => array(
      'variables' => array(
        'heading' => FALSE,
        'docs' => array(),
        'all_documents_link' => FALSE,
      ),
      'template' => 'theme/cluster-docs-cards-list'
    ),
    'cluster_docs_table_list' => array(
      'variables' => array(
        'heading' => FALSE,
        'docs' => array(),
        'all_documents_link' => FALSE,
        'reset_link' => FALSE,
      ),
      'template' => 'theme/cluster-docs-table-list'
    ),
    'cluster_docs_featured_documents' => array(
      'variables' => array(
        'docs' => array(),
      ),
      'template' => 'theme/cluster-docs-featured-documents'
    ),
    // @TODO more general for any link.
    'cluster_docs_all_docs_link' => array(
      'variables' => array(
        'path' => FALSE,
        'text' => t('Browse all documents'),
        'class' => 'browse-all-documents',
      ),
      'file' => 'theme/cluster_docs.theme.inc',
    ),
    'cluster_docs_facet' => array(
      'variables' => array(
        'title' => FALSE,
        'options' => array(),
        'child' => array(),
      ),
      'file' => 'theme/cluster_docs.theme.inc',
    )
  );
}
